"""Module for Dynamic Factor Model specification

Main command to run model
    - `c19_dfm run`
"""
import json
from pathlib import Path

import pandas as pd
import statsmodels.api as sm
from rich import print as pprint
from sklearn.preprocessing import MinMaxScaler
from statsmodels.tsa.stattools import adfuller

from covid19_drdfm.processing import DATA_DIR, adjust_pandemic_response


def get_factors() -> dict[str, (str, str)]:
    """Fetch pre-defined factors for model

    Returns:
        dict[str, (str, str)]: Factors from `./data/processed/factors.yaml`
    """
    with open(DATA_DIR / "factors.json") as f:
        return json.load(f)


def is_constant(column) -> bool:
    """Returns True if a DataFrame column is constant"""
    return all(column == column.iloc[0])


def state_process(df: pd.DataFrame, state: str) -> pd.DataFrame:
    """Prepare data for a given state

    Args:
        df (pd.DataFrame): DataFrame generated by `c19dfm process`
        state (str): Two-letter State Code to filter by (CA, AK, etc...)

    Returns:
        pd.DataFrame: Processed DataFrame, ready for model
    """
    df = df[df.State == state]
    #! The trunctation will be removed when data is updated in OCT - A.C.
    df = df[:-12]
    df = adjust_pandemic_response(df)
    df = df.pivot(index="Time", columns="State")
    const_cols = [x for x in df.columns if is_constant(df[x])]
    pprint(f"Constant Columns...dropping\n{const_cols}")
    df = df.drop(columns=const_cols)
    return normalize(df)


def normalize(df: pd.DataFrame) -> pd.DataFrame:
    """Normalize data and make stationary - scaling for post-DFM Synthetic Control Model

    Args:
        df (pd.DataFrame): State data, pre-normalization

    Returns:
        pd.DataFrame: Normalized and stationary DataFrame
    """
    # Normalize data
    scaler = MinMaxScaler()
    norm_df = pd.DataFrame(scaler.fit_transform(df), columns=df.columns) * 100
    stationary_df = norm_df.diff()
    stationary_df = stationary_df.fillna(0)

    non_stationary_columns = []
    for col in stationary_df.columns:
        result = adfuller(stationary_df[col])
        p_value = result[1]
        if p_value > 0.25:
            non_stationary_columns.append(col)

    pprint("Columns that fail the ADF test (non-stationary):", non_stationary_columns)
    return flatten_multiindex_columns(stationary_df)


#! This is convoluted - redundant to track state in multi-index then add to col names
def flatten_multiindex_columns(df: pd.DataFrame) -> pd.DataFrame:
    """Flatten Multi-index array

    Args:
        df (pd.DataFrame): Normalized and stationary DataFrame

    Returns:
        pd.DataFrame: Flattened DF
    """
    cols = df.columns.to_flat_index()
    new_cols = []
    for col in cols:
        new_col = "_".join(map(str, col))
        new_cols.append(new_col)
    return pd.DataFrame(df.values, columns=new_cols)


def run_model(df: pd.DataFrame, state: str, outdir: str) -> sm.tsa.DynamicFactor:
    """Run DFM for a given state

    Args:
        df (pd.DataFrame): DataFrame processed via `covid19_drdfm.run`
        state (str): Two-letter state code to process
        outdir (str): Output directory for model CSV files

    Returns:
        sm.tsa.DynamicFactor: Dynamic Factor Model

    """
    factors = get_factors()
    factors = {x + state: y for x, y in factors.items()}
    factor_multiplicities = {"Global": 2}
    df = state_process(df, state)
    model = sm.tsa.DynamicFactorMQ(df, factors=factors, factor_multiplicities=factor_multiplicities)
    pprint(model.summary())
    results = model.fit(disp=10)
    pprint(results.summary())
    outdir = Path(outdir)
    pprint(f"Saving output to {outdir}/(model|results).csv")
    with open(outdir / "model.csv", "w") as f:
        f.write(model.summary().as_csv())
    with open(outdir / "results.csv", "w") as f:
        f.write(results.summary().as_csv())
    return model
