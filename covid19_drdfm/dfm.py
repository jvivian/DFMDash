# %%
"""Module for Dynamic Factor Model specification

Main command to run model
    - `c19_dfm run`
"""
from dataclasses import dataclass
from pathlib import Path

import pandas as pd
import statsmodels.api as sm
from rich import print as pprint
from sklearn.preprocessing import MinMaxScaler
from statsmodels.tsa.stattools import adfuller

from covid19_drdfm.processing import adjust_pandemic_response, get_factors


@dataclass
class StateData:
    df: pd.DataFrame
    model: sm.tsa.DynamicFactorMQ
    # results:


def is_constant(column) -> bool:
    """Returns True if a DataFrame column is constant"""
    return all(column == column.iloc[0])


def state_process(df: pd.DataFrame, state: str) -> pd.DataFrame:
    """Prepare data for a given state

    Args:
        df (pd.DataFrame): DataFrame generated by `c19dfm process`
        state (str): Two-letter State Code to filter by (CA, AK, etc...)

    Returns:
        pd.DataFrame: Processed DataFrame, ready for model
    """
    df = df[df.State == state]
    #! The trunctation will be removed when data is updated in OCT - A.C.
    df = df[:-12]
    const_cols = [x for x in df.columns if is_constant(df[x])]
    pprint(f"Constant Columns...dropping\n{const_cols}")
    df = df.drop(columns=const_cols)
    df = adjust_pandemic_response(df)
    return normalize(df)


def normalize(df: pd.DataFrame) -> pd.DataFrame:
    """Normalize data and make stationary - scaling for post-DFM Synthetic Control Model

    Args:
        df (pd.DataFrame): State data, pre-normalization

    Returns:
        pd.DataFrame: Normalized and stationary DataFrame
    """
    df = df.drop(columns=["Time"]) if "Time" in df.columns else df
    # Normalize data
    scaler = MinMaxScaler()
    norm_df = pd.DataFrame(scaler.fit_transform(df), columns=df.columns) * 100
    # stationary_df = norm_df.diff()
    stationary_df = norm_df.diff().drop(0, axis=0)  #! Dropping first after diff
    # stationary_df = stationary_df.fillna(0)

    non_stationary_columns = []
    for col in stationary_df.columns:
        result = adfuller(stationary_df[col])
        p_value = result[1]
        if p_value > 0.25:
            non_stationary_columns.append(col)

    pprint("Columns that fail the ADF test (non-stationary):", non_stationary_columns)
    return stationary_df


def run_model(df: pd.DataFrame, state: str, outdir: Path) -> sm.tsa.DynamicFactor:
    """Run DFM for a given state

    Args:
        df (pd.DataFrame): DataFrame processed via `covid19_drdfm.run`
        state (str): Two-letter state code to process
        outdir (str): Output directory for model CSV files

    Returns:
        sm.tsa.DynamicFactor: Dynamic Factor Model

    """
    # Factors
    factors = get_factors()
    factor_multiplicities = {"Global": 2}
    # Run model on a given state and print results
    df = state_process(df, state)
    # Remove factors without an associated column
    factor_keys = list(factors.keys())
    [factors.pop(var) for var in factor_keys if var not in df.columns]
    outdir.mkdir(exist_ok=True)
    out = outdir / state
    pprint(f"Saving state input information to {out}")
    out.mkdir(exist_ok=True)
    df.to_excel(out / "df.xlsx")
    df.to_csv(out / "df.tsv", sep="\t")
    if (out / "model.csv").exists():
        return
    try:
        model = sm.tsa.DynamicFactorMQ(df, factors=factors, factor_multiplicities=factor_multiplicities)
        pprint(model.summary())
        results = model.fit(disp=10)
    except Exception as e:
        with open(outdir / "failed_convergence.txt", "a") as f:
            f.write(f"{state}\t{e}\n")
        return
    pprint(results.summary())
    # Output
    pprint(f"Saving output to {outdir}")
    with open(out / "model.csv", "w") as f:
        f.write(model.summary().as_csv())
    with open(out / "results.csv", "w") as f:
        f.write(results.summary().as_csv())
    return model, results


def test_model(df: pd.DataFrame, state: str, outdir: Path) -> sm.tsa.DynamicFactor:
    """Run DFM for a given state

    Args:
        df (pd.DataFrame): DataFrame processed via `covid19_drdfm.run`
        state (str): Two-letter state code to process
        outdir (str): Output directory for model CSV files

    Returns:
        sm.tsa.DynamicFactor: Dynamic Factor Model

    """
    # Factors
    factors = get_factors()
    # factors =
    #     x[:-1]: y for x, y in factors.items()
    # }  # TODO: Fix in config to remove this now that multindex is removed
    factor_multiplicities = {"Global": 2}
    # Run model on a given state and print results
    df = state_process(df, state)
    drop_vars = ["proportion_vax2", "Proportion"]
    new = df.drop(columns=drop_vars)
    # [factors.pop(var) for var in drop_vars]
    #! COLUMN REMOVAL
    outdir.mkdir(exist_ok=True)
    out = outdir / state
    pprint(f"Saving state input information to {out}")
    out.mkdir(exist_ok=True)
    new.to_excel(out / "df.xlsx")
    new.to_csv(out / "df.tsv", sep="\t")
    if (out / "model.csv").exists():
        return
    try:
        model = sm.tsa.DynamicFactorMQ(new, factors=factors, factor_multiplicities=factor_multiplicities)
        pprint(model.summary())
        results = model.fit(disp=10)
    except Exception as e:
        with open(outdir / "failed.txt", "a") as f:
            f.write(f"{state}\t{e}\n")
        return
    pprint(results.summary())
    # Output
    pprint(f"Saving output to {outdir}")
    with open(out / "model.csv", "w") as f:
        f.write(model.summary().as_csv())
    with open(out / "results.csv", "w") as f:
        f.write(results.summary().as_csv())
    return model, results


# #%%
# from covid19_drdfm.processing import get_df


# df = get_df()
# model, results = run_model(df, 'AL', outdir=Path('./test-delete-NY-foo'))

# # %%
