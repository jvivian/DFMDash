"""Module for Dynamic Factor Model specification

Main command to run model
    - `c19_dfm run`
"""

from dataclasses import dataclass
from pathlib import Path

import pandas as pd
import statsmodels.api as sm
from rich import print as pprint
from statsmodels.tsa.stattools import adfuller

from covid19_drdfm.constants import FACTORS


@dataclass
class StateData:
    df: pd.DataFrame
    model: sm.tsa.DynamicFactorMQ
    # results:


def is_constant(column) -> bool:
    """Returns True if a DataFrame column is constant"""
    return all(column == column.iloc[0])


def state_process(df: pd.DataFrame, state: str) -> pd.DataFrame:
    """Prepare data for a given state

    Args:
        df (pd.DataFrame): DataFrame generated by `c19dfm process`
        state (str): Two-letter State Code to filter by (CA, AK, etc...)

    Returns:
        pd.DataFrame: Processed DataFrame, ready for model
    """
    df = df[df.State == state].fillna(0)
    #! The trunctation will be removed when data is updated in OCT - A.C.
    df = df[:-12]
    const_cols = [x for x in df.columns if is_constant(df[x])]
    pprint(f"Constant Columns...dropping\n{const_cols}")
    df = df.drop(columns=const_cols)
    return df


def get_nonstationary_columns(df: pd.DataFrame) -> list[str]:
    """Run AD-Fuller on tests and report failures

    Args:
        df (pd.DataFrame): Input DataFrame

    Returns:
        list[str]: List of columns that failed AD-Fuller test
    """
    non_stationary_columns = []
    for col in df.columns:
        result = adfuller(df[col])
        p_value = result[1]
        if p_value > 0.25:
            non_stationary_columns.append(col)

    pprint(f"Columns that fail the ADF test (non-stationary)\n{non_stationary_columns}")
    return non_stationary_columns


def run_model(df: pd.DataFrame, state: str, outdir: Path):  # -> sm.tsa.DynamicFactor:
    """Run DFM for a given state

    Args:
        df (pd.DataFrame): DataFrame processed via `covid19_drdfm.run`
        state (str): Two-letter state code to process
        outdir (str): Output directory for model CSV files

    # Returns:
        # sm.tsa.DynamicFactor: Dynamic Factor Model

    """
    df = state_process(df, state)
    save_df(df, outdir, state)
    # Remove factors without an associated column
    factors = FACTORS.copy()
    factor_keys = list(factors.keys())
    [factors.pop(var) for var in factor_keys if var not in df.columns]
    # Load cached model if exists
    if (outdir / state / "model.csv").exists():
        model = sm.load(outdir / state / "model.csv")
        return model, model.fit(disp=10)
    # Try to run model, if it fails, note failure and return. Rust handles this so much better
    try:
        factor_multiplicities = {"Global": 2}
        model = sm.tsa.DynamicFactorMQ(df, factors=FACTORS, factor_multiplicities=factor_multiplicities)
        results = model.fit(disp=10)
    except Exception as e:
        with open(outdir / "failed_convergence.txt", "a") as f:
            f.write(f"{state}\t{e}\n")
        return None, None
    # Save output
    save_results(df, model, results, outdir=outdir / state, verbose=True)
    return model, results


def save_df(df: pd.DataFrame, outdir: Path, state: str):
    """Save DataFrame as CSV / Excel

    Args:
        df (pd.DataFrame): Input DataFrame to model
        outdir (Path): output directory
        state (str): State to subset by
    """
    outdir.mkdir(exist_ok=True)
    state_dir = outdir / state
    pprint(f"Saving state input information to {state_dir}")
    state_dir.mkdir(exist_ok=True)
    df.to_excel(state_dir / "df.xlsx")
    df.to_csv(state_dir / "df.tsv", sep="\t")


def save_results(df: pd.DataFrame, model, results, outdir: Path, verbose: bool = False):
    """Save model and results to given directory

    Args:
        df pd.DataFrame: _description_
        model (_type_): _description_
        results (_type_): _description_
        outdir (Path): _description_
        verbose (bool, optional): _description_. Defaults to False.
    """
    if verbose is True:
        pprint(model.summary())
        pprint(results.summary())
        # Output
        pprint(f"Saving output to {outdir}")
    with open(outdir / "model.csv", "w") as f:
        f.write(model.summary().as_csv())
    with open(outdir / "results.csv", "w") as f:
        f.write(results.summary().as_csv())
    non_stationary_cols = get_nonstationary_columns(df)
    if non_stationary_cols:
        with open(outdir / "non-stationary-columns.txt", "w") as f:
            f.write("\n".join(non_stationary_cols))
