"""Module for Dynamic Factor Model specification

Main command to run model
    - `c19_dfm run`
"""

from pathlib import Path
from typing import Optional

import pandas as pd
import statsmodels.api as sm
from rich import print as pprint
from statsmodels.tsa.stattools import adfuller

from covid19_drdfm.constants import DIFF_COLS, FACTORS, LOG_DIFF_COLS
from covid19_drdfm.processing import diff_vars, get_raw, normalize, write


def is_constant(column) -> bool:
    """Returns True if a DataFrame column is constant"""
    return all(column == column.iloc[0])


def state_process(df: pd.DataFrame, state: str) -> pd.DataFrame:
    """Prepare data for a given state

    Args:
        df (pd.DataFrame): DataFrame generated by `c19dfm process`
        state (str): Two-letter State Code to filter by (CA, AK, etc...)

    Returns:
        pd.DataFrame: Processed DataFrame, ready for model
    """
    df = df[df.State == state].pipe(diff_vars, cols=DIFF_COLS).pipe(diff_vars, cols=LOG_DIFF_COLS, log=True).iloc[1:]
    df = normalize(df).fillna(0)
    const_cols = [x for x in df.columns if is_constant(df[x])]
    pprint(f"Constant Columns...dropping\n{const_cols}")
    return df.drop(columns=const_cols).set_index("Time", drop=True)


def get_nonstationary_columns(df: pd.DataFrame) -> list[str]:
    """Run AD-Fuller on tests and report failures

    Args:
        df (pd.DataFrame): Input DataFrame

    Returns:
        list[str]: List of columns that failed AD-Fuller test
    """
    non_stationary_columns = []
    for col in df.columns:
        result = adfuller(df[col])
        p_value = result[1]
        if p_value > 0.25:
            non_stationary_columns.append(col)

    pprint(f"Columns that fail the ADF test (non-stationary)\n{non_stationary_columns}")
    return non_stationary_columns


def run_parameterized_model(
    df: pd.DataFrame,
    state: str,
    outdir: Path,
    columns: Optional[list[str]] = None,
    factors: dict[str, tuple[str, str]] = FACTORS,
    global_multiplier: int = 2,
    maxiter: int = 10_000,
) -> sm.tsa.DynamicFactor:
    """Run DFM for a given state

    Args:
        df (pd.DataFrame): DataFrame processed via `covid19_drdfm.run`
        state (str): Two-letter state code to process
        outdir (str): Output directory for model CSV files

    Returns:
        sm.tsa.DynamicFactor: Dynamic Factor Model
    """
    df = state_process(df, state)
    _ = get_nonstationary_columns(df)
    df = df[[x for x in list(columns) if x in df.columns]] if columns else df
    factors = {k: v for k, v in factors.items() if k in df.columns}
    _save_input(df, state, columns, outdir)
    if global_multiplier == 0:
        factors = {k: {v[1]} for k, v in factors.items()}
        model = sm.tsa.DynamicFactorMQ(df, factors=factors)
    else:
        factor_multiplicities = {"Global": global_multiplier}
        model = sm.tsa.DynamicFactorMQ(df, factors=factors, factor_multiplicities=factor_multiplicities)
    try:
        results = model.fit(disp=10, maxiter=maxiter)
    except Exception as e:
        with open(outdir / "failed.txt", "a") as f:
            f.write(f"{state}\t{e}\n")
        return
    _save_output(df, model, results, state, outdir)
    return model


def _save_input(df, state, columns, outdir):
    outdir.mkdir(exist_ok=True)
    out = outdir / state
    out.mkdir(exist_ok=True)
    raw = get_raw().query("State == @state")
    raw = raw[columns + ["Time"]] if columns else raw
    raw = raw.set_index("Time").loc[df.index]
    write(raw, out / "raw.csv")
    write(df, (out / "df.xlsx"))
    write(df, out / "df.csv")


def _save_output(df, model, results, state, outdir):
    out = outdir / state
    with open(out / "model.csv", "w") as f:
        f.write(model.summary().as_csv())
    with open(out / "results.csv", "w") as f:
        f.write(results.summary().as_csv())
    filtered = results.factors["filtered"]
    filtered["State"] = state
    raw = pd.read_csv(out / "raw.csv", index_col=0)
    filtered.index = raw.index
    filtered = filtered.merge(raw, left_index=True, right_index=True)
    filtered.to_csv(out / "filtered-factors.csv")
